#pragma once
#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <new>
#include <ostream>

/// A stateful object used to inject a Browser SDK [`Snippet`] inside a HTML
/// document. Use
/// [`injector_create`] to create a new one.
///
/// Note: this struct is exposed as an FFI opaque pointer. Structure layout is
/// irrelevant to the library consumer as it is only allocated and accessed by
/// the library.
struct Injector;

/// A Browser SDK snippet. Use [`snippet_create_from_json`] to create a new one.
///
/// In practice, a Browser SDK snippet looks like a HTML &lt;script&gt; tag
/// containing what is needed to load and initialize the SDK. See [public
/// documentation][1].
///
/// # Memory ownership
///
/// `Snippet` instances are owned by the library and should be freed by
/// [`snippet_cleanup`].
///
/// # Error handling
///
/// The Snippet creation can fail for the following reasons:
///
/// | Reason                    | `error_code` | `error_message`    |
/// |---------------------------|--------------|--------------------|
/// | JSON parse failure        | `1`          | A message generated by
/// [`serde_json`][2] usually containing the error position within the JSON
/// string. | | Unsupported major version | `2`          | `"Unsupported major
/// version {version}"` |
///
///
/// [1]: https://docs.datadoghq.com/real_user_monitoring/browser/#cdn-async
/// [2]: https://docs.rs/serde_json
struct Snippet {
  /// The error code. `0` when the snippet was created successfully.
  uint8_t error_code;
  /// The error message. `NULL` when the snippet was created successfully.
  const char *error_message;
  /// The snippet bytes length.
  uint32_t length;
};

/// A pointer to a sub-array of bytes, used within [`InjectorResult`].
///
/// # Memory ownership
///
/// See [`InjectorResult`].
struct BytesSlice {
  /// Number of bytes.
  uint32_t length;
  /// A pointer to the first byte of the sub-array.
  const uint8_t *start;
  /// Whether the pointer refers to the chunk provided to the [`injector_write`]
  /// function. This is useful when using the library from a language providing
  /// safer ways to access memory than using raw pointers.
  ///
  /// By using this flag, one could avoid some unsafe pointer manipulation by
  /// computing the slice index relative to the start of the chunk, and use this
  /// index to access the memory-owned instance of the chunk.
  ///
  /// # Example (in "simplified" Rust as an illustration)
  ///
  /// ```rust
  /// let chunk = b"foobar";
  /// let result = injector_write(injector, chunk.as_ptr(), chunk.len());
  /// for slice in result.slices {
  ///     if slice.from_incoming_chunk {
  ///         let start_index = slice.start - chunk.as_ptr();
  ///         let end_index = start_index + slice.end;
  ///         outgoing_stream.write(&chunk[start_index..end_index])
  ///     } else {
  ///         outgoing_stream.write(unsafe {
  ///         std::slice::from_raw_parts(slice.start, slice.len) })
  ///     }
  /// }
  /// ```
  bool from_incoming_chunk;
};

/// The result of a call to [`injector_write`] or [`injector_end`]. It
/// represents a list of binary slices to be written to the outgoing stream.
///
/// In its current implementation, at most 4 slices can be returned. While rare,
/// it is possible that 0 slices are returned.
///
/// [`InjectorResult`] instances (and the memory they point to) should *not* be
/// used anymore once `injector_write` or `injector_end` are called with the
/// same `Injector` instance.
///
/// # Memory ownership
///
/// `InjectorResult` is allocated on the stack. By itself it does not own any
/// memory, but can contain pointers to:
///
/// * portions of the chunk provided to [`injector_write`]. This chunk is owned
/// by the library consumer and should be freed once it is not used anymore.
///
/// * internal buffers owned by the [`Injector`] instance. Those buffers will be
/// cleared by
/// [`injector_cleanup`].
struct InjectorResult {
  /// Number of returned slices (any number from 0 to 4).
  uint32_t slices_length;
  /// A pointer to the first returned slice.
  const BytesSlice *slices;
  /// Whether the injection occurred while processing the current chunk.
  bool injected;
};

/// FFI compatible structure used by the library consumers to describe RUM
/// Browser SDK initialization parameters.
struct RumConfiguration {
  const char *client_token;
  const char *application_id;
  const char *site;
  const char *default_privacy_level;
  bool track_resources;
  float session_sample_rate;
};

/// FFI compatible structure used by the library consumers to describe a Browser
/// SDK configuration
struct Configuration {
  uint32_t major_version;
  RumConfiguration rum;
};

extern "C" {

/// Create an [`Injector`] injector based on a [`Snippet`].
///
/// # Memory ownership
///
/// The `Injector` instance returned by this function is owned by the library
/// and should be freed by using [`injector_cleanup`] once done using it.
///
/// # Example
///
/// ```c
/// Injector* injector = injector_create(snippet);
///
/// // ... use injector
///
/// injector_cleanup(injector);
/// ```
Injector *injector_create(const Snippet *snippet);

/// Free the [`Injector`] associated memory.
///
/// # Memory safety
///
/// Do not use the `injector` instance after calling this function.
void injector_cleanup(Injector *injector);

/// Write part of an HTML document to the [`Injector`].
///
/// This function should not be called while another [`InjectorResult`] from the
/// same `Injector` is still being processed.
///
/// # Memory ownership
///
/// The library consumer owns the memory related to the `chunk` argument, and
/// should free it once it's not used anymore.
///
/// See [`InjectorResult`] documentation for details about the returned value
/// memory ownership.
///
/// # Example
///
/// ```c
/// InjectorResult result = injector_write(injector, buffer, buffer_length);
/// for (int index = 0; index < result.slices_length; index += 1) {
///   BytesSlice slice = result.slices[index];
///
///   write(outgoing_stream, slice.start, slice.length);
/// }
/// ```
InjectorResult injector_write(Injector *injector, const uint8_t *chunk,
                              uint32_t length);

/// Notify the [`Injector`] that the full HTML document has been written.
///
/// If the injection did not happen yet, a slice of the same size as the snippet
/// containing only white space will be returned to "pad" the response, so it
/// has the same length as the announced `content-length`.
///
/// This function should not be called while another [`InjectorResult`] from the
/// same `Injector` is still being processed.
///
/// # Memory ownership
///
/// See [`InjectorResult`] documentation for details about the returned value
/// memory ownership.
///
/// # Example
///
/// ```c
/// InjectorResult result = injector_end(injector);
/// for (int index = 0; index < result.slices_length; index += 1) {
///   BytesSlice slice = result.slices[index];
///
///   write(outgoing_stream, slice.start, slice.length);
/// }
InjectorResult injector_end(Injector *ffi_injector);

/// Create a snippet from a C string representing a JSON-encoded object.
///
/// # JSON format
///
/// The JSON object must be an object with the following properties:
///
/// * `majorVersion`: the major version of the Browser SDK to use. Currently,
/// only `5` is supported.
///
/// * `rum`: an object containing the RUM Browser SDK configuration. See [public
/// documentation][1]. The following parameters are the most common ones:
///
/// | Parameter                 | Type      | Default value |
/// |---------------------------|-----------|---------------|
/// | `clientToken`             | `string`  | **Required**  |
/// | `applicationId`           | `string`  | **Required**  |
/// | `site`                    | `string`  | `datadoghq.com` |
/// | `service`                 | `string`  |               |
/// | `env`                     | `string`  |               |
/// | `version`                 | `string`  |               |
/// | `sessionSampleRate`       | `number`  | `100`         |
/// | `sessionReplaySampleRate` | `number`  | `0`           |
/// | `defaultPrivacyLevel`     | `string`  | `"mask"`      |
/// | `trackUserInteractions`   | `boolean` | `false`       |
/// | `trackResources`          | `boolean` | `false`       |
/// | `trackLongTasks`          | `boolean` | `false`       |
///
/// Note: not all parameters supported by the Browser SDK can be serialized as
/// JSON (ex: `beforeSend` is expected to be a function). Those parameters are
/// not supported yet by this library.
///
/// # Error handling
///
/// This function always returns a valid `Snippet` pointer. When an error occurs
/// during the snippet formatting, the `Snippet` instance contains an error code
/// and an error message. See [`Snippet`] documentation for details.
///
/// # Memory ownership
///
/// The `json` pointer is owned by the caller and should be freed by the caller.
/// No reference to the provided memory is kept by the library.
///
/// The `Snippet` instance returned by this function is owned by the library and
/// should be freed by using [`snippet_cleanup`] once done using it, even if an
/// error occurred during its creation.
///
/// # Example
///
/// ```c
/// Snippet* snippet = snippet_create_from_json(
///    "{\"majorVersion\":5,\"rum\":{\"clientToken\":\"foo\",\"applicationId\":\"bar\"}}");
///
/// if (snippet->error_code != 0) {
///    printf("Error: %s\n", snippet->error_message);
///    snippet_cleanup(snippet);
///    return;
/// }
///
/// // ... use the snippet
///
/// snippet_cleanup(snippet);
/// ```
///
/// [1]:
/// https://docs.datadoghq.com/real_user_monitoring/browser/#initialization-parameters
Snippet *snippet_create_from_json(const char *json);

/// Create a snippet from a [`Configuration`] structure. Returns `NULL` in case
/// of error.
Snippet *snippet_create_from_struct(Configuration configuration);

/// Free the [`Snippet`] associated memory.
///
/// # Memory safety
///
/// Do not use the `snippet` instance after calling this function.
void snippet_cleanup(Snippet *snippet);

/// Get the snippet bytes length
uint32_t snippet_get_length(const Snippet *snippet);

}  // extern "C"
