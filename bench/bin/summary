#!/usr/bin/env python3

import argparse
import math
import statistics


def parse_options():
    parser = argparse.ArgumentParser(
                    prog = 'summary',
                    description = 'Print statistics summary for files')

    parser.add_argument('--cutoff', type=int)
    parser.add_argument('--floor', type=int)
    parser.add_argument('--significance', action='store_true')

    parser.add_argument('file', nargs='+')

    return parser.parse_args()


def parse_path(path):
    column = 1
    path, *rest = path.split('@')
    if len(rest):
        assert len(rest) == 1
        column = int(rest[0])
    return path, column

options = parse_options()

values_by_path = {}

for arg in options.file:
    path, column = parse_path(arg)
    values = []
    with open(path) as file:
        for line in file:
            line = line.strip()
            if len(line) == 0 or line[0] == '#':
                continue
            try:
                value = int(line.split()[column - 1])
            except IndexError:
                continue
            if options.cutoff is not None and value > options.cutoff:
                continue
            if options.floor is not None and value < options.floor:
                continue
            values.append(value)

    if options.significance:
        values_by_path[arg] = values

    print(f'{path}@{column}')
    for stat in 'mean median mode pstdev stdev'.split():
        print(f'\t{stat}\t', getattr(statistics, stat)(values))

    print('\tmin\t', min(values))
    print('\tmax\t', max(values))
    print('\tcount\t', len(values))
    print('\t√c̅o̅u̅n̅t̅\t', math.sqrt(len(values)))

if options.significance:
    pairs = frozenset(frozenset([left, right]) for left in options.file for right in options.file if left != right)
    for complement, sample in pairs:
        print()
        print(f'Null hypothesis: "{complement}" and "{sample}" have the same mean.')
        population = values_by_path[complement] + values_by_path[sample]
        pstdev = statistics.pstdev(population)
        pmean = statistics.mean(population)
        smean = statistics.mean(values_by_path[sample])
        z = (smean - pmean) / (pstdev / math.sqrt(len(values_by_path[sample])))
        print(f'\tAlternative hypothesis: "{sample}" has the lower mean.')
        p = statistics.NormalDist().cdf(z)
        print(f'\t\tz = {z}, p = {p}\t{"✅" if p < 0.01 else ""}')
        print(f'\tAlternative hypothesis: "{sample}" has the higher mean.')
        print(f'\t\tz = {z}, p = {1 - p}\t{"✅" if 1 - p < 0.01 else ""}')
